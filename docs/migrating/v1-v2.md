# Migrating from v1 to V2

Carbon v2 has moved the testing tools from Jasmine and Karma to [Jest](https://facebook.github.io/jest/).

## Carbon Factory Test Setup changes

For the simplest of setups there should be no required changes when migration from v1 and v2. `gulp test` and `gulp test --build` should work as before and both now automatically include coverage reports. For more complicated setups where you are defining your own coverage limit, spec helpers or additional modules to run babel on you will need to provide some extra configuration via a `jest.conf.json` file.

The basic `gulp test` command is just a wrapper for the following options:

* watch - Enters Jest watch interactive CLI
* onlyChanged - Looks at your git integration for files that have changed and immediately runs the appropriate spec files

The wrapper uses the Carbon Factory jest.conf.json file as a base and merges in any changes passed to the gulp task.

e.g.

The following gulp task will ingnore all __spec__.js and definition.js files in the src directory and turn off watch mode

```js
gulp.task('test', SpecTask({
  jestConfig: {
    path: '/src/***/**/!(__spec__|definition).js',
    watch: false
  }
}));
```

We recommend that instead of just adding this configuration to the gulpfile you set up a jest.conf.json file. This file can then be used for the JestCLI as well as to the wrapped Carbon Factory version.

In the top level of your UI directory add a `jest.conf.json` file which looks like the following.

```js
// jest.conf.json
{
  "testMatch": [ "**/__spec__.js" ],
  "moduleDirectories": [ "src", "node_modules" ],
  "collectCoverage": true,
  "coverageReporters": [ "text-summary", "html" ],
  "coverageDirectory": "<rootDir>/coverage",
  "notify": true,
  "coverageThreshold": {
    "global": {
      "branches": 100,
      "functions": 100,
      "lines": 100,
      "statements": 100
    }
  }
}
```

Now we want to reference this file in our gulpfile. Jest allows you to add a base config file as a `preset`.

```js
gulp.task('test', SpecTask({
  jestConfig: {
    preset: "<rootDir>/jest.conf.json"
    rootDir: process.cwd(),
  }
}));
```

The gulp test and gulp test --build task will now run relative to your config.

We also want to enable the JestCLI to work with your defined config file. To do this you will need to open up your package.json file and add a script and a jest key.

```js
// package.json
"scripts": {
  "test": "jest"
},
// ...
"jest": {
  "preset": "./jest.conf.json"
}
```

You should now be able to run the test suite with the following commands

* `npm run test`
* `gulp test`


For more details on running tests see the [Running Specs Document](https://github.com/Sage/carbon-factory/blob/master/docs/running-tests.md)

### Spec helpers

v1 of Carbon Factory allowed you to define spec_helpers that would run before any of the tests. In Jest these helpers can be passed a setupFiles to the jest.conf. To add a basic spec helper file add the following to your jest.conf.json file.

```js
// jest.conf.json
"setupFiles": [
  "./src/__spec_helper__/index.js"
],
```

In this example all the spec helper logic is contained in one file, `index.js`. You can however pass multiple files to the array or import different files from within the index.js file itself.


## Migrating code from Jasmine to Jest

Jest is based (forked?) from Jasmine and therefore follows a lot of the same syntax, style and conventions. This means that migrating from jasmine should be easy. However as a fork, Jest, has removed some of Jasmines features in favor of their own implementations. We have compiled a small list of common changes you may be required to make to convert your tests from Jasmine to Jest.

### Mock Functions

Creating mock functions in Jest can be done using `jest.fn();`

```js
const myMock = jest.fn();
```

The mock object has a mock property attached to it, which lets you track calls, arguments, etc.:

```js
expect(myMock.mock.calls.length).toBe(1);
expect(myMock.mock.calls[0][0]).toBe(‘foo’);
```

You can setup return values using mockReturnValue, and mockReturnValueOnce:

```js
myMock.mockReturnValueOnce(‘moo’)
	.mockReturnValueOnce(‘oink’)
	.mockReturnValue(‘neigh’);
// myMock returns ‘moo’, ‘oink’, then ‘neigh’ for each subsequent call
```

Also, if your mock needs to support method chaining you can use mockReturnThis:

```js
myMock.mockReturnThis();
```

### Timer Mocks
Where previously you used jasmine.clock() to mock setTimeout and setInterval, in Jest you need to use jest.useFakeTimers():
```js
jest.useFakeTimers();
```

In your tests, you can control the timers via three methods:

```js
// Runs all timers until they have all been executed
jest.runAllTimers();
// Run only the pending timers
jest.runOnlyPendingTimers();
// Run timers until the elapsed ms
jest.runTimersToTime(1000);
```

You can clear any pending timers using:

```js
jest.clearAllTimers();
```

### Mocking the Date
Jasmine let you mock specific dates using jasmine.clock().mockDate(). Jest doesn’t appear to have any direct replacement for this itself, so we’re using the MockDate package as a replacement. You use it like so:

```js
// Import the package
import MockDate from ‘mockdate’;

// Setup the mock behaviour
const baseTime = new Date(‘2/2/2000’);
MockDate.set(baseTime);
// new Date().toString() => “Wed Feb 02 2000 00:00:00”

// Reset the mock date
MockDate.reset()
```

### Ajax Testing
Now we’re using Jest, you can no longer use Jasmine Ajax in your specs. Instead you’ll need to mock the appropriate modules and / or functions as required.

For example, if you need to test code that uses SuperAgent for Ajax requests, you’ll find a handy mock implementation of SuperAgent in the __mocks__ folder. To use this in your specs:

Import SuperAgent into your spec:
```js
import Request from ‘superagent’;
```

Tell Jest to mock superagent:
```js
jest.mock(‘superagent’);
```

You can then mock the Request methods you need to and check it was called with the correct arguments:

```js
it(‘queries for data with the correct page and rows’, () => {
  Request.query = jest.fn().mockReturnThis();
  …
  expect(Request.query).toBeCalledWith(‘page=1&rows=10’);
}
```

Or override the mock response:
```js
Request.__setMockResponse({
  status() {
    return 200;
  },
  ok() {
    return true;
  },
  body: {
    data: ['foo']
  }
});
```
Or the mock error:
```js
Request.__setMockError({
  message: 'Unsuccessful HTTP response'
});
```

Or the mock delay if required:
```js
Request.__setMockDelay(true);
```
